<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/Craaaazy/Craaaazy.github.io/2021/04/10/Springboot/"/>
    <url>/Craaaazy/Craaaazy.github.io/2021/04/10/Springboot/</url>
    
    <content type="html"><![CDATA[<h2 id="Aop实现Log"><a href="#Aop实现Log" class="headerlink" title="Aop实现Log"></a>Aop实现Log</h2><p>类上使用@Aspect，@Component两个注解，类中使用@PonintCut value的值execution的匹配<br>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)<br>            throws-pattern?)<br>execution(方法修饰符(可选)  返回类型  类路径 方法名  参数  异常模式(可选)) </p><h3 id="execution表达式"><a href="#execution表达式" class="headerlink" title="execution表达式"></a>execution表达式</h3><p>除了返回类型，方法名还有参数之外，其他都是可选的<br> ret-type-pattern:可以为<em>表示任何返回值,全路径的类名等.<br>name-pattern:指定方法名,<em>代表所以,set</em>,代表以set开头的所有方法.<br>parameters pattern:指定方法参数(声明的类型),         ()匹配没有参数；  (..)代表任意多个参数；   (</em>)代表一个参数，但可以是任意型；    (<em>,String)代表第一个参数为任何值,第二个为String类型。<br>下面给几个例子：<br>1）execution(public * <em>(..))——表示匹配所有public方法<br>2）execution(</em> set</em>(..))——表示所有以“set”开头的方法<br>3）execution(* com.xyz.service.AccountService.<em>(..))——表示匹配所有AccountService接口的方法<br>4）execution(</em> com.xyz.service.<em>.</em>(..))——表示匹配service包下所有的方法<br>5）execution(* com.xyz.service..<em>.</em>(..))——表示匹配service包和它的子包下的方法</p><span id="more"></span><p>由于是由动态代理实现的，所以只有public方法可以拦截下来，如果使用cgLib的话，只有public和protected方法可以拦截下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(value = &quot;execution(public * com.example.demo.controller..*.*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">controllerLog</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//只是用来标记一个signature，即pointcut的切入点，无其他意义</span><br></code></pre></td></tr></table></figure><h3 id="不同的advice的拦截顺序的问题"><a href="#不同的advice的拦截顺序的问题" class="headerlink" title="不同的advice的拦截顺序的问题"></a>不同的advice的拦截顺序的问题</h3><h4 id="情况一，只有一个Aspect类："><a href="#情况一，只有一个Aspect类：" class="headerlink" title="情况一，只有一个Aspect类："></a>情况一，只有一个Aspect类：</h4><p>　　无异常：@Around（proceed()之前的部分） → @Before → 方法执行 → @Around（proceed()之后的部分） → @After → @AfterReturning<br>　　有异常：@Around（proceed(之前的部分)） → @Before → 扔异常ing → @After → @AfterThrowing    （大概是因为方法没有跑完抛了异常，没有正确返回所有@Around的proceed()之后的部分和@AfterReturning两个注解的加强没有能够织入）</p><h4 id="情况二，同一个方法有多个-Aspect类拦截："><a href="#情况二，同一个方法有多个-Aspect类拦截：" class="headerlink" title="情况二，同一个方法有多个@Aspect类拦截："></a>情况二，同一个方法有多个@Aspect类拦截：</h4><p>　　单个Aspect肯定是和只有一个Aspect的时候的情况是一样的，但不同的Aspect里面的advice的顺序呢？？答案是不一定，像是线程一样，没有谁先谁后，除非你给他们分配优先级，同样地，在这里你也可以为@Aspect分配优先级，这样就可以决定谁先谁后了。<br>优先级有两种方式：</p><ul><li>实现org.springframework.core.Ordered接口，实现它的getOrder()方法</li><li>给aspect添加@Order注解，该注解全称为：org.springframework.core.annotation.Order</li></ul><p>不管是哪种，都是order的值越小越先执行；<br><a href="https://www.cnblogs.com/wangshen31/p/9379197.html">参考来源</a></p><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>创建一个xxFilter使用注解@WebFilter(filterName = “testFilter”, urlPatterns = “/*”)，实现Filter接口，并在启动类添加@ServletComponentScan，注意实现doFilter时，要调用filterChain.doFilter(req, res);将filter传递下去。可以用@Order()来实现顺序。</p><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>如下一个ExceptionHandler会处理参数校验时报的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;<br>    Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);<br><br>    <span class="hljs-meta">@ExceptionHandler(javax.validation.ConstraintViolationException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleClassNotFoundException</span><span class="hljs-params">(javax.validation.ConstraintViolationException ex, HttpServletRequest req)</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;exception: &quot;</span> + ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>@Retention只能用于修饰其他的Annotation，<strong>用于指定被修饰的Annotation被保留多长时间。</strong><br>java文件有三个时期：<strong>编译,class,运行。@Retention默认是class</strong><br>前面我们是使用反射来得到注解上的信息的，<strong>因为@Retention默认是class，而反射是在运行时期来获取信息的</strong>。因此就获取不到Annotation的信息了。于是，就得在自定义注解上修改它的RetentionPolicy值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//不加会报NullPointerException</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br><br>    <span class="hljs-comment">//成员只能是String，数组，Class，枚举，注解</span><br>    <span class="hljs-function">String <span class="hljs-title">username</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;linda&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 20</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Class aClass = Test.class;<br>        Method method = aClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, String.class, <span class="hljs-keyword">int</span>.class);<br>        MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);<br>        String username = myAnnotation.username();<br>        <span class="hljs-keyword">int</span> age = myAnnotation.age();<br><span class="hljs-comment">//        Object obj = aClass.newInstance();</span><br><span class="hljs-comment">//        method.invoke(obj, username, age);</span><br><br>        System.out.println(<span class="hljs-string">&quot;username: &quot;</span> + username + <span class="hljs-string">&quot;, age: &quot;</span> + age);<br>    &#125;<br><br>    <span class="hljs-meta">@MyAnnotation(username = &quot;zhongfucheng&quot;, age = 20)</span><span class="hljs-comment">//如果参数只有一个且为value，那么不用写参数名</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String username, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/Craaaazy/Craaaazy.github.io/2021/04/10/Java%20Concurrency/"/>
    <url>/Craaaazy/Craaaazy.github.io/2021/04/10/Java%20Concurrency/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>sleep与yield 前者让进程进入阻塞态，后者进入就绪态，sleep会出让cpu但不会释放锁。</p><h2 id="visiable-问题"><a href="#visiable-问题" class="headerlink" title="visiable 问题"></a>visiable 问题</h2><p>问题重现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">x</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(flag);<br>            System.out.println(<span class="hljs-string">&quot;cc&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            flag = <span class="hljs-keyword">false</span>;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，程序将不会输出任何字符，也就是说在Thread2中修改过的flag并没有应用到Tread1中，这就是可见性问题。解决办法有两种，一是给flag加上volatile修饰，二是将flag变量改为AtomicBoolean类型。<br>然而并没有这么简单，这时sleep()和yield()将产生完全不同的情况，如果使用yield()则无论是否为volatile都可以退出程序（当然只是这个例子比较简单，复杂的程序yield()应该也会产生可见性问题）。</p><blockquote><ul><li>volatile：此关键字保证了变量在线程的可见性，所有线程访问由volatile修饰的变量，都必须从主存中读取后操作，并在工作内存修改后立即写回主存，保证了其他线程的可见性，同样效果的关键字还有final。</li><li>synchronized：所有同步操作都必须保证 1、原子性 2、可见性，所以在同步块中发生的变化会立马写回主存</li><li>sleep：此方法只会让出CPU执行时间，并不会释放锁。</li></ul></blockquote><p>将上述代码while部分进行修改（依旧是sleep()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(flag)&#123;<br>    <span class="hljs-keyword">byte</span>[] bts2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>此时发现，程序已经可以正常退出了，原因可能是new byte[]已经不是cpu耗时了，cpu空闲出来马上读取主内存中的flag进工作内存，从而正常退出。其原因来自于cpu的占用，<a href="https://www.cnblogs.com/tv151579/p/9395452.html">更多参考</a>。</p><span id="more"></span><h3 id="关于Volatile"><a href="#关于Volatile" class="headerlink" title="关于Volatile"></a>关于Volatile</h3><p>volatile保证单个读写动作具有原子性，但是volatile++这种复合操作不具有原子性。</p><h2 id="迭代器与modCount"><a href="#迭代器与modCount" class="headerlink" title="迭代器与modCount"></a>迭代器与modCount</h2><p>我们知道在Collection的实现类中，总是有modCount这个变量，它会记录该数据结构被修改的次数，比如扩表、删除、添加数据等修改了表结构（大小）的操作。modCount被用来对Iterator进行检查，即在迭代器进行迭代时，如果检查到modCount改变了，那么会直接抛出ConcurrentModificationException，这就是Fast-Fail机制。<br>顺便补充一下关于迭代器的作用，迭代器在链状结构中更加常用，在使用时可以不用担心具体的实现，凡是实现了该接口的，好处在于可以使用相同方式去遍历集合中元素，比如说在代码中将List改为了Set实现，这时不需要改变遍历代码就可以，不用担心出bug（see checkForComodification()）。不允许如此操作是因为线程不安全。<br>补充，字符串的拼接在编译后会变成StringBuilder.append(),再进行toString()。这样也是线程不安全的。Collection在通过其他的Collection进行初始化时也会间接调用迭代器，所以也是线程不安全的，类似的还有hashCode(), equals(), retainAll()等等。</p><h2 id="同步与并发容器"><a href="#同步与并发容器" class="headerlink" title="同步与并发容器"></a>同步与并发容器</h2><p>同步容器有Collections.synchronizedList()等，并发容器有ConcurrentHashMap等。<br>再来回忆一下什么是同步，在OS里面的内容，同步是指在完成一项任务之前必须等待前一项任务完成，简单来说就是生产-消费模型。<br>JDK1.5新增了Queue和BlockingQueue两个容器，普通的FIFO队列ConcurrentLinkedQueue，(非并发)优先级队列PriorityQueue，尽管我们可以通过List来模拟实现Queue的功能，但是如果忽略掉随机访问的需求的话，Queue可以获得更好的并发实现。BlockingQueue是阻塞队列，和Queue相比，如果BlockingQueue是空的，那么取操作将会阻塞，等到有下一个插入操作后再进行（对于有界队列，插入操作同理），而Queue会直接返回null。<br>BlockingQueue接口的实现类，LinkedBlocingQueue和ArrayBlockingQueue是FIFO队还有优先级队列PriorityBlockingQueue。补充关于PriorityQueue的使用:</p><blockquote><p>PriorityQueue 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//通过改造器指定排序规则</span><br>        PriorityQueue&lt;Student&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;Student&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">//按照分数低到高，分数相等按名字</span><br>                <span class="hljs-keyword">if</span>(o1.getScore() == o2.getScore())&#123;<br>                    <span class="hljs-keyword">return</span> o1.getName().compareTo(o2.getName());<br>                &#125;<br>                <span class="hljs-keyword">return</span> o1.getScore() - o2.getScore();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//入列</span><br>        q.offer(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;dafei&quot;</span>, <span class="hljs-number">20</span>));<br>        q.offer(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;will&quot;</span>, <span class="hljs-number">17</span>));<br>        q.offer(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;setf&quot;</span>, <span class="hljs-number">30</span>));<br>        q.offer(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;bunny&quot;</span>, <span class="hljs-number">20</span>));<br><br>        <span class="hljs-comment">//出列</span><br>        System.out.println(q.poll());  <span class="hljs-comment">//Student&#123;name=&#x27;will&#x27;, score=17&#125;</span><br>        System.out.println(q.poll());  <span class="hljs-comment">//Student&#123;name=&#x27;bunny&#x27;, score=20&#125;</span><br>        System.out.println(q.poll());  <span class="hljs-comment">//Student&#123;name=&#x27;dafei&#x27;, score=20&#125;</span><br>        System.out.println(q.poll());  <span class="hljs-comment">//Student&#123;name=&#x27;setf&#x27;, score=30&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个实现类是SynchronousQueue，它不维护一个内存空间，它维护一个线程清单，适合消费者多的场合，<a href="https://www.jianshu.com/p/d5e2e3513ba3">SynchronousQueue解释-简书</a>中有简单的解释：</p><blockquote><p>SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p></blockquote><h4 id="双端队列与窃取模式"><a href="#双端队列与窃取模式" class="headerlink" title="双端队列与窃取模式"></a>双端队列与窃取模式</h4><p>Deque和BlockingDeque分别扩展了Queue和BlockingQueue，他们是双端队列，可以在队首队尾进行插入移除，实现类为ArrayDeque和LinkedBlockingDeque。<br>双端队列与窃取模式相连，在窃取工作(work stealing)设计中，所有消费者都使用双端队列，当某一个消费者线程完成时，可以从其他消费者线程队列的末尾的任务。</p><h2 id="Synchronizor"><a href="#Synchronizor" class="headerlink" title="Synchronizor"></a>Synchronizor</h2><h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><blockquote><p><strong>闭锁是一种同步工具，可以延迟线程直到其达到其终止状态。</strong></p></blockquote><p>闭锁可以用来确保特定活动直到其他的活动完成后才发生，简单来说，先创建的线程先运行那么就有了“先发优势”，开始闸门控制能让线程同时释放，也能够控制线程等待最后一个活动完成，如：</p><ol><li>确保一个计算不会执行，直到他所需要的资源被初始化。</li><li>确保一个服务不会开始，直到它依赖的其他服务都已经开始。</li><li>等待，直到活动的所有部分都为继续处理做好充分准备。</li></ol><p>实现类：CountDownLatch(int count);count数表示阻塞事件数，await()将使线程等待，countDown()会执行-1操作，如果count == 0那么等待结束释放线程。<br>FutureTask(new Callable(){/<em>实现call方法，可设置返回类型，需要return值</em>/})，参数为callable接口，可以作为预读取来使用，调用其FutureTask.get()即可获得数据，如果加载完成会直接返回这些数据，反之，将会等待加载结束再继续。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>Semaphore类，初始化保存一个permit，acquire()分配permit–，release()释放permit++，如果permit为0那么acquire阻塞。信号量可以用来实现资源池，比如数据库连接池。</p><h3 id="关卡（barrier）"><a href="#关卡（barrier）" class="headerlink" title="关卡（barrier）"></a>关卡（barrier）</h3><p>类似于闭锁，不同的是只有所有线程都到达时，再释放，闭锁等待的是事件，barrier等待的是其他线程，到达关卡点时，调用await()阻塞，当其他所有线程都调用await()后，释放。可通过CyclicBarrier实现。</p><h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul><li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li><li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li></ul><h2 id="任务执行-Excutor"><a href="#任务执行-Excutor" class="headerlink" title="任务执行 Excutor"></a>任务执行 Excutor</h2><h3 id="每任务每线程-thread-per-task"><a href="#每任务每线程-thread-per-task" class="headerlink" title="每任务每线程(thread-per-task)"></a>每任务每线程(thread-per-task)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-keyword">final</span> Socket connection = socket.accept();<span class="hljs-comment">//监听</span><br>    Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;doSomeTask();&#125;<br>    &#125;<br>    <span class="hljs-keyword">new</span> Thread(task).start();<span class="hljs-comment">//只要有请求就创建线程处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为每一个任务创建一个线程，执行任务的负载已经脱离了主线程，主线程可以直接等待下一个请求，在中等负荷下有较好表现，只要请求到达速度未超过服务器处理请求的速度。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>线程生命周期开销，创建销毁需要时间，如果task很简单，那么会给系统带来不必要的负担。</li><li>资源消耗，如果线程数大于可用处理器数，那么线程会空闲，占用更多内存，给gc带来压力，而且线程相互竞争也会造成消耗。</li><li>稳定性。</li></ul><p>总而言之，需要限制线程的数量。</p><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor只是一个简单的接口，但是为灵活而强大的Executor框架提供了基础，这个跨级啊可以用于异步任务的执行，还为任务提交和任务执行之间的解耦提供了标准的方法，为使用Runnable描述任务提供了通用的方式。Executor的实现还提供了对生命周期的支持，可以添加统计收集、应用程序管理和监视器等扩展。<br>Executor基于生产-消费者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Executor exec = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-keyword">final</span> Socket connection = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">80</span>).accpet();<br>    Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;doSomeTask();&#125;<br>    &#125;<br>    exec.excute(task);<span class="hljs-comment">//与上面的实现不同的地方</span><br>&#125;<br><span class="hljs-comment">//只需要一点点修改就可以把它变成上面一种实现(per thread per task)</span><br><span class="hljs-comment">//即继承Executor并实现execute时new Thread</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Excutor</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span></span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(r).start();<br>        <span class="hljs-comment">//r.run();所有线程将会同步执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论何时看到new Thread(runnable).start();都可以用Executor代替Thread。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>newFixedThreadPool：创建一个定长的线程池，每提交一个任务就创建一个线程直到最大长度。</li><li>newCachedThreadPool：创建一个可缓存的线程池，灵活回收空闲线程或增加新的线程。</li><li>newSingleThreadExecutor：创建一个单线程化的executor，它只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor会保证任务依照任务队列所规定的顺序(FIFO,LIFO)执行。</li><li>newScheduledThreadPool：创建一个定长的线程池，支持定时及周期性的任务，类似于Timer。<h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4>jvm在所有非deamon线程结束后才会退出，因此，如果无法正确关闭线程，将组织jvm结束。为了解决这个生命周期问题，ExecutorService接口扩展了Executor并添加了一些生命周期管理方法（如shutDown(), isShutDown(), shutDownNow(), isTerminated()等）。<br>ExecutorService暗示了生命周期有三个状态，running/shutting down(关闭)/terminated(终止)，shut down方法会启动一个较为平缓的关闭过程：停止接受新的任务并等待现有的任务完成（包括尚未开始的任务），shutdownnow会执行强制的关闭过程，尝试取消所有在执行和在队列中尚未开始的任务。实现类有ThreadPoolExecutor，<a href="https://blog.csdn.net/qq_41900081/article/details/93045795">关于用ThreadPoolExecutor实现ExecutorService的操作</a>。<h4 id="携带结果的任务-Callable-Future"><a href="#携带结果的任务-Callable-Future" class="headerlink" title="携带结果的任务:Callable/Future"></a>携带结果的任务:Callable/Future</h4>Runnable只是一个相当有限的抽象，虽然它能够产生一些边界效应，比如记录日志，或将数据存入一个共享的数据结构，但是run不能返回一个值或者抛出一个异常。<br>一个Executor框架执行任务的生命周期有四个阶段：创建、提交、开始和完成。在Executor框架中总可以取消已经提交但尚未开始的任务，但是对于已经开始的任务，只有它们响应中断，才可以取消，取消一个已经完成的任务没有影响。<br>在Future中，任务的状态（尚未开始，运行中，完成）决定了get方法的行为，如果完成，会返回或者抛出异常，如果没有完成，get会阻塞直到他完成。如果抛出异常将被封装成ExecutionException，被取消会抛出CancellationException，etc。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService exec = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>List&lt;Future&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    Future&lt;Integer&gt; future = exec.submit(()-&gt;&#123;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;=<span class="hljs-number">100</span>; j++) &#123;<br>            sum+=j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;);<br>    list.add(future);<br>&#125;<br>exec.shutdown();<br><span class="hljs-keyword">for</span> (Future&lt;Integer&gt; future : list) &#123;<br>    System.out.println(future.get());<br>&#125;<br></code></pre></td></tr></table></figure>注意这里的匿名类是callable接口，当任务被submit后，将会由线程池分配线程运行，等待调用Future.get()时返回计算完成的值，如果计算时间很长，将会在get处阻塞。<h4 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h4>CompletionService整合了Executor和BlockingQueue的功能，可以将Callable任务提交给它执行，然后使用类似于队列中的take和poll方法，在结果完整可用时获取，像一个打包的Future。实现类是ExecutorCompletionService。<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4>只有通过execute提交的任务，才能将它抛出的异常交给未捕获异常的处理器，通过submit提交的任务，抛出的任何异常，都讲被认为是任务返回状态的一部分，submit异常终结的话，会在future.get()中被抛出ExecutorException。<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2>两个线程试图以不同的顺序获得多个相同的锁时，很容易产生死锁，即锁的嵌套。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object left = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object right = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRight</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (left)&#123;<br>        System.out.println(<span class="hljs-string">&quot;sync left in leftRight&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (right)&#123;<br>            System.out.println(<span class="hljs-string">&quot;leftRight&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightLeft</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (right)&#123;<br>        System.out.println(<span class="hljs-string">&quot;sync right in rightLeft&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (left)&#123;<br>            System.out.println(<span class="hljs-string">&quot;rightLeft&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>一个解决办法是，给left和right锁一个int型的hash值，public static int leftHash = System.indentityHashCode(left)，之后在RightLeft方法中加判断。如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightLeft</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(rightHash &lt; leftHash)&#123;<br>        <span class="hljs-keyword">synchronized</span> (right)&#123;<br>            System.out.println(<span class="hljs-string">&quot;sync right in rightLeft&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                System.out.println(<span class="hljs-string">&quot;rightLeft&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftHash &lt; rightHash) &#123;<br>        <span class="hljs-keyword">synchronized</span> (left)&#123;<br>            System.out.println(<span class="hljs-string">&quot;sync left in rightLeft&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                System.out.println(<span class="hljs-string">&quot;rightLeft&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (ifSameHash)&#123; ... &#125;<span class="hljs-comment">//如果恰好两个hash相等时。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>hash值也有很小的几率相等，这时候再加一个公用的锁即可。如果具有一个唯一的，不变的，并且具有可比性的key，比如账号，那么制定锁的顺序就更加容易了：通过key来排定对象顺序，就可以省去公用锁的需要。<h4 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h4>在实际运用中，死锁可能出现得比较隐晦，比如在synchronize方法中调用了其他的synchronized方法，很容易产生死锁，而所谓开放调用的意思是，将方法名中的synchronized精确到具体处理变量的部分，将需要的变量clone一份copy，然后便可以避免死锁，虽然这样在某些环境下会使变量的获取更慢，不及时，但是避免了死锁。<h4 id="定时锁"><a href="#定时锁" class="headerlink" title="定时锁"></a>定时锁</h4>检测死锁和从死锁中恢复的技术，使用每个显式Lock类中的定时tryLock特性，来代替内部锁机制。在内部锁中，只要没有获得锁，就会永远保持等待。而显式锁在超过定义时间后，就返回失败。由Lock接口实现。<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4>使用线程的优先级不当可能引起饥饿，无限循环、无线等待也会引起饥饿。线程API定义的线程优先级仅仅作为调度的参考，线程API定义了十个优先级级别，并对应到操作系统相应的优先级中。这样的映射是平台相关的，所以两个JAVA优先级可能映射到某操作系统中相同的优先级。<br>在大多数的Java应用程序中，线程具有相同的优先级，线程优先级并不是方便的工具，提高一个线程的优先级往往什么都不能改变，却会引起一个线程的优先级高于其他的，从而导致饥饿。只要你开始改变线程的优先级，程序的行为就变得与平台(OS)相关了，而且有饥饿风险，所以，尽量抵制修改线程优先级。<br>Thread.yield();将会使线程进入就绪状态，重新竞争cpu资源，如果该线程的优先级最高，则任然会是它继续占领cpu运行，而且不会释放锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                cb.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                incrementI();<br>            &#125;<br>        &#125;);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                cb.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                incrementI();<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">0</span>);<span class="hljs-comment">//pointd</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incrementI</span><span class="hljs-params">()</span></span>&#123;<br>        i ++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; increment i to &quot;</span> + i);<br>    &#125;<br></code></pre></td></tr></table></figure>point处，如果为yield，那么输出将不会间隔，即先t2再t1，如果为sleep(0)那么t2执行3遍后会出现间隔。</li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有枷锁和解锁的方法都是显式的。ReentrantLock实现Lock接口，提供了与Synchronized相同的互斥和内存可见性的保证。获得ReentrantLock的锁与进入synchronized块有相同的内存语义，释放也与退出synchronized块有相同的内存语义。<br>内部锁在一些功能上有局限，不能中断那些正在等待获取锁的线程，并且在请求失败的情况下，必须无限等待。内部锁必须在获取它们的代码块中被释放；这简化了代码，与异常处理机制能进行良好互动，但是某些情况下，ReentrantLock机制提供了更好的活跃度和性能。<br>在使用Lock时，一定要记得在finally块中释放，lock.unlock()。当忘记释放lock时，将很难追踪错误的发生点，因为没有记录锁本应该被释放的位置和时间，这就是为什么Lock不能完全代替Synchronized块的原因。</p><h3 id="可轮询可定时的锁请求"><a href="#可轮询可定时的锁请求" class="headerlink" title="可轮询可定时的锁请求"></a>可轮询可定时的锁请求</h3><p>如果你不能获得所有的需要的锁，那么使用可定时的与可轮询的获取方式(tryLock)使你能够重新拿到控制权，他会释放你已经获得的锁。简单说，使用synchronized和lock()都会拿到锁，但是不会释放，使用trylock遇到阻塞时会尝试释放锁并尝试重新获取，可以用来处理哲学吃饭问题。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁与闯入锁，在高并发下，公平锁因为调度会使效率低下，并不一定好用。其他略。</p><h3 id="ReentrantLock与内部锁"><a href="#ReentrantLock与内部锁" class="headerlink" title="ReentrantLock与内部锁"></a>ReentrantLock与内部锁</h3><p>ReentrantLock和synchronized在语义上是一样的，那么为什么不放弃使用synchronized呢？第一个是ReentrantLock必须要unlock，另一个synchronized的优点是，线程传储可以显式那个调用框架获得了锁，并能识别哪些发生了死锁的线程，在java6中也能获得ReentrantLock的加锁信息。但是即使如此，能使用synchronized的时候还是建议使用synchronized，因为它是基于jvm的，可以进行持续优化。</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>简单说，读线程与读线程可以同时运行，但是写-写，写-读时，会阻塞。接口为readwritelock，实现类时ReentrantReadWriteLock。当访问多与读取时，可以展现出强大的伸缩性，在高并发下，比ReentrantLock效率更高。</p><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>在程序中，有一部分的行为是需要等待其他线程来进行调用的，这时候使用while(true)会使程序效率变得很低，所以我们使用Object.wait()和Object.notify()/notifyAll()来处理。<br>Object.wait()会自动释放锁，并请求OS挂起线程，让其它的线程获得该锁进而修改对象状态。notify会随机唤醒一个wait，notifyAll会唤醒全部，通常来说notify的使用有局限性，notifyAll在很多wait时有性能上的小问题。</p><h3 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h3><p>在之前的synchronized和Lock的对比中可知，synchronized是有局限性的，当它不灵活时，显式锁就可以派上用场，Lock是广义的内部锁，而Condition是广义的内部条件队列。Condition接口中，await实现Object.wait()，signal实现Object.notify()。<br>用Condition cond = lock.newCondition();来初始化，一个lock可以new多个Condition不同于Object.wait();等一个Obj只能作为一个条件队列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java Concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库相关</title>
    <link href="/Craaaazy/Craaaazy.github.io/2021/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <url>/Craaaazy/Craaaazy.github.io/2021/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL和sqlserver的区别"><a href="#MySQL和sqlserver的区别" class="headerlink" title="MySQL和sqlserver的区别"></a>MySQL和sqlserver的区别</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>体积小、速度快、总体拥有成本低，开源；MySQL的核心程序采用完全的多线程编程。线程是轻量级的进程，它可以灵活地为用户提供服务，而不过多的系统资源。用多线程和C语言实现的mysql能很容易充分利用CPU；<br>有很多存储引擎可以选择，如MyISAM, Heap, InnoDB, and Berkeley DB。但是缺乏一些存储过程功能。<br>但是在多表关联、子查询优化、统计函数等方面是软肋，而且只支持极简单的HINT。</p><h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><p>稳定性强，代价是增加额外的复杂操作，磁盘存储，内存损耗等等，需要更强的硬件支持。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>MySQL简单查询非常快，但是用函数/join/group等方式查时会慢一些。sqlserver的简单查询速度不如MySQL，但在复杂查询时，性能降低得不多。但MySQL可以通过针对表结构设计来避免复杂查询（多冗余，少关联）。sqlserver的并发性能不如MySQL。<br>sqlserver的性能比MySQL要好。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>sqlserver功能比mysql多，比如存储过程/触发器/丰富的函数/图形化管理页面/自动维护的计划任务等</p><h2 id="安全功能"><a href="#安全功能" class="headerlink" title="安全功能"></a>安全功能</h2><p>MySQL有一个用于改变数据的二进制日志。因为它是二进制，这一日志能够快速地从主机上复制数据到客户机上。即使服务器崩溃，这一二进制日志也会保持完整，而且复制的部分也不会受到损坏。 <br>在SQL服务器中，你也可以记录SQL的有关查询，但这需要付出很高的代价。 </p><h1 id="常见sql优化策略"><a href="#常见sql优化策略" class="headerlink" title="常见sql优化策略"></a>常见sql优化策略</h1><p>首先，对于MySQL层优化我一般遵从五个原则：</p><ol><li>减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</li><li>返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io</li><li>减少交互次数：批量DML操作，函数存储等减少数据连接次数</li><li>减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</li><li>利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源<span id="more"></span>总结到SQL优化中，就三点:</li></ol><ul><li>最大化利用索引；</li><li>尽可能避免全表扫描；</li><li>减少无效数据的查询；</li></ul><p>理解SQL优化原理 ，首先要搞清楚SQL执行顺序：</p><h2 id="SELECT语句-语法顺序："><a href="#SELECT语句-语法顺序：" class="headerlink" title="SELECT语句 - 语法顺序："></a><strong>SELECT语句 - 语法顺序：</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT <span class="hljs-operator">&lt;</span>limit_number<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="SELECT语句-执行顺序："><a href="#SELECT语句-执行顺序：" class="headerlink" title="SELECT语句 - 执行顺序："></a><strong>SELECT语句 - 执行顺序：</strong></h2><p><strong>FROM</strong><br>&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。<br><strong>ON</strong><br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br>**JOIN **&lt;join, left join, right join…&gt;<br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br><strong>WHERE</strong><br>&lt;where条件&gt; # 对上述虚表进行筛选<br><strong>GROUP BY</strong><br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br><strong>HAVING</strong><br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br><strong>SELECT</strong><br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br><strong>DISTINCT</strong></p><h1 id="数据除重"><a href="#数据除重" class="headerlink" title="数据除重"></a>数据除重</h1><p><strong>ORDER BY</strong><br>&lt;排序条件&gt; # 排序<br><strong>LIMIT</strong><br>&lt;行数限制&gt;</p><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a><strong>SQL优化策略</strong></h2><p><strong>来自<a href="https://zhuanlan.zhihu.com/p/299051996">SQL优化最干货总结（2020最新版）</a></strong></p><h3 id="一、避免不走索引的场景"><a href="#一、避免不走索引的场景" class="headerlink" title="一、避免不走索引的场景"></a>一、避免不走索引的场景</h3><p><strong>1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%陈%&#x27;</span><br></code></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;陈%&#x27;</span><br></code></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询，</p><ul><li>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置</li><li>使用FullText全文索引，用match against 检索</li><li>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级</li><li>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。</li></ul><p><strong>2. 尽量避免使用in 和not in，会导致引擎走全表扫描。</strong>如下（此处已经被优化，mysql优化器会判断全表扫描快or索引快）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>优化方式：如果是连续数值，可以用between代替。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果是子查询，可以用exists代替。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走索引</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B);<br><span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id);<br></code></pre></td></tr></table></figure><p><strong>3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：（并非所有的or都用不到索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>优化方式：可以用union代替or。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>4. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> score <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>优化方式：可以给字段添加默认值0，对0值进行判断。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。</strong><br>可以将表达式、函数操作移动到等号右侧。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 全表扫描</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score<span class="hljs-operator">/</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br><span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-operator">*</span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>6. 当数据量大时，避免使用where 1=1的条件。</strong>通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> username, age, sex <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。<br><strong>7. 查询条件不能用 &lt;&gt; 或者 !=</strong><br>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。<br><strong>8. where条件仅包含复合索引非前置列</strong><br>如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part2<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> key_part3<span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>9. 隐式类型转换造成不使用索引</strong><br>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> col_varchar<span class="hljs-operator">=</span><span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p><strong>10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br> <br><span class="hljs-comment">-- 走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><p>对于上面的语句，数据库的处理顺序是：</p><ul><li>第一步：根据where条件和统计信息生成执行计划，得到数据。</li><li>第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。</li><li>第三步：返回排序后的数据。</li></ul><p>当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。<br>这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。<br><strong>11. 正确使用hint优化语句</strong><br>MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。</p><ol><li>USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)…</li><li>IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) …</li><li>FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) …</li></ol><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="hljs-keyword">WHERE</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="二、SELECT语句其他优化"><a href="#二、SELECT语句其他优化" class="headerlink" title="二、SELECT语句其他优化"></a>二、SELECT语句其他优化</h3><p>**1. 避免出现select ***<br>首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。<br>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。<br>建议提出业务实际需要的列数，将指定列名以取代select *。<br><strong>2. 避免出现不确定结果的函数</strong><br>特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。<br><strong>3.多表关联查询时，小表在前，大表在后。</strong><br>在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。<br>例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。<br><strong>4. 使用表的别名</strong><br>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。<br><strong>5. 用where字句替换HAVING字句</strong><br>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。<br>where和having的区别：where后面不能使用组函数<br><strong>6.调整Where字句中的连接顺序</strong><br>MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</p><h2 id="left-join-和inner-join"><a href="#left-join-和inner-join" class="headerlink" title="left join 和inner join"></a>left join 和inner join</h2><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 <br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>来自<a href="https://blog.csdn.net/weixin_42181824/article/details/82261988">数据库索引原理，及MySQL索引类型</a></p><h2 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h2><p>一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。</p><h3 id="索引的不足之处"><a href="#索引的不足之处" class="headerlink" title="索引的不足之处"></a>索引的不足之处</h3><p>过多的使用索引将会造成滥用。因此索引也会有它的缺点：</p><ul><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li><li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</li></ul><p>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p><h3 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h3><ol><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3>使用索引时，有以下一些技巧和注意事项：</li></ol><ul><li>索引不会包含有NULL值的列</li></ul><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><ul><li>使用短索引</li></ul><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><ul><li>索引列排序</li></ul><p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><ul><li>like语句操作</li></ul><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p><ul><li><p>不要在列上进行运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-keyword">YEAR</span>(adddate)<span class="hljs-operator">&lt;</span><span class="hljs-number">2007</span>;<br></code></pre></td></tr></table></figure><p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> adddate<span class="hljs-operator">&lt;</span>‘<span class="hljs-number">2007</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>’;<br></code></pre></td></tr></table></figure></li><li><p>不使用NOT IN和&lt;&gt;操作</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3></li></ul><ol><li>存在null值</li><li>not条件（不要用not in 或者 not exist）</li><li>like ‘%xx’（通配符在前时）</li><li>条件包括函数</li><li>数据类型转换</li><li>范围条件(&lt;，&gt;)后列出索引<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4>最基本类型，没有任何限制，唯一的任务就是加快访问速度。允许在定义的列中添加重复值和空值。<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4>唯一索引和普通索引类似，避免数据出现重复。<br>值必须唯一可以为空。一般用create unique index创建。<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4>特殊的唯一索引，不能用create index创建，唯一且不空。表中只有一个主键索引。<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4>对文本内容进行搜索的索引。<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4>多列值组成的一个索引，专门用于组合索引，效率大于索引合并。<h3 id="从物理角度"><a href="#从物理角度" class="headerlink" title="从物理角度"></a>从物理角度</h3><h4 id="聚集索引（聚簇索引（Clustered-Index））"><a href="#聚集索引（聚簇索引（Clustered-Index））" class="headerlink" title="聚集索引（聚簇索引（Clustered Index））"></a>聚集索引（聚簇索引（Clustered Index））</h4>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。<br>聚集索引确定表中数据的物理顺序。聚集索引类似于字典，按字母排序，每个字母下有多个字（相当于数据列）。所以对于聚集索引，叶子结点即存储了真实的数据行。所以通过聚集索引可以直接获取到数据库中的数据。<br>一般建表的时候，数据库就会为主键建立了聚簇索引<h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。<br>非聚集索引的叶层不包含数据页， 叶结点包含索引字段值及指向数据页数据行的逻辑指针（每个索引行包含非聚集键值以及一个或多个行定位器，这些行定位器指向有该键值的数据行（如果索引不唯一，则可能是多行））。所以非聚集索引不能直接获取到数据，需要通过定位器来获取数据。</li></ol><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>InnoDB：事物优先（适合高并发，是行锁）</li><li>MyISAM：性能优先（表锁）<h3 id="表锁与行锁"><a href="#表锁与行锁" class="headerlink" title="表锁与行锁"></a>表锁与行锁</h3>当插入数据时，就锁定表，这叫做”锁表”；当更新数据时，就锁定行，这叫做”锁行”。<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li></ul><ol><li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p></li><li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p></li><li><p>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p></li><li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p></li><li><p>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3></li><li><p>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p></li><li><p>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p></li><li><p>系统奔溃后，MyISAM恢复起来更困难，能否接受；</p></li><li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p><h1 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h1><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p></li></ol><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复读和幻读区别：</strong><br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p><h2 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些?"></a>事务隔离级别有哪些?</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p></li><li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p></li><li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p></li><li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p><h1 id="mysql-explain解释"><a href="#mysql-explain解释" class="headerlink" title="mysql explain解释"></a>mysql explain解释</h1><h2 id="EXPLAIN列的解释："><a href="#EXPLAIN列的解释：" class="headerlink" title="EXPLAIN列的解释："></a>EXPLAIN列的解释：</h2></li><li><p>table：显示这一行的数据是关于哪张表的</p></li><li><p>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL</p></li><li><p>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p></li><li><p>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p></li><li><p>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好</p></li><li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数</p></li><li><p>rows：MYSQL认为必须检查的用来返回请求数据的行数</p></li><li><p>Extra：关于MYSQL如何解析查询的额外信息。坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢</p><h2 id="Extra列返回的描述的意义"><a href="#Extra列返回的描述的意义" class="headerlink" title="Extra列返回的描述的意义:"></a>Extra列返回的描述的意义:</h2></li><li><p>Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p></li><li><p>Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了</p></li><li><p>Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p></li><li><p>Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行</p></li><li><p>Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候</p></li><li><p>Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p></li><li><p>Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</p></li><li><p>system 表只有一行：system表。这是const连接类型的特殊情况</p></li><li><p>const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待</p></li><li><p>eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用</p></li><li><p>ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好</p></li><li><p>range:这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况</p></li><li><p>index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）</p></li><li><p>ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/"/>
    <url>/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="1、运行时数据区域"><a href="#1、运行时数据区域" class="headerlink" title="1、运行时数据区域"></a>1、运行时数据区域</h2><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/image.png" class title="1.7之前 运行时数据区域"><p>上图1.7以前</p><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" class title="1.7之前 运行时数据区域"><h3 id="关于字符串常量池"><a href="#关于字符串常量池" class="headerlink" title="关于字符串常量池"></a>关于字符串常量池</h3><p>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；<br>在JDK7.0版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。</p><h3 id="java虚拟机栈（vm-stack）"><a href="#java虚拟机栈（vm-stack）" class="headerlink" title="java虚拟机栈（vm stack）"></a>java虚拟机栈（vm stack）</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表、操作数栈、常量池引用</strong>等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br>该区域可能抛出以下异常：</p><span id="more"></span><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；如class A, class B 相互包含时相互调用会报此错误。<a href="https://blog.csdn.net/gentlezuo/article/details/90580116">例子</a></li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。<h3 id="那么方法-函数如何调用？"><a href="#那么方法-函数如何调用？" class="headerlink" title="那么方法/函数如何调用？"></a><strong>那么方法/函数如何调用？</strong></h3>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。<br>Java 方法有两种返回方式：</li></ul><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为虚拟机使用的Native方法服务。<br>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><p>线程私有的：程序计数器，虚拟机栈，本地方法栈<br>线程共享的：堆(heap)，方法区，直接内存</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong><br>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong><br>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永生代(Permanent Generation)</li></ol><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" class title="JVM堆内存结构-jdk8"><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量</strong>、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。<br><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md#253-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3-permgen-%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4-metaspace-%E5%91%A2">为什么要将永久代-permgen-替换为元空间-metaspace-呢</a></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong><br>**</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" class title="Java创建对象的过程"><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" class title="内存分配的两种方式"><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="2、JVM-GC"><a href="#2、JVM-GC" class="headerlink" title="2、JVM GC"></a>2、JVM GC</h2><h3 id="对象优先在-eden-区分配"><a href="#对象优先在-eden-区分配" class="headerlink" title="对象优先在 eden 区分配"></a>对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.</p><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/vm_option.png" class title="vm option"><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/fenpei.png" class title="fenpei"><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<strong>为什么？</strong>为了避免为大对象分配内存时由于<strong>分配担保机制</strong>带来的复制而降低效率。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。<strong>默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6</strong><br><strong>简单来说，有一个targetSuvivorRatio(default 50%)，如果当前这个年龄以上的年龄加起来超过了这个比例，那么发动MajorGC。</strong></p><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：<br>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>效率高，但是如果两个对象相互引用对方，会导致引用计数器不为0，gc无法回收。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="1．强引用（StrongReference）"><a href="#1．强引用（StrongReference）" class="headerlink" title="1．强引用（StrongReference）"></a>1．强引用（StrongReference）</h4><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h4 id="2．软引用（SoftReference）"><a href="#2．软引用（SoftReference）" class="headerlink" title="2．软引用（SoftReference）"></a>2．软引用（SoftReference）</h4><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h4 id="3．弱引用（WeakReference）"><a href="#3．弱引用（WeakReference）" class="headerlink" title="3．弱引用（WeakReference）"></a>3．弱引用（WeakReference）</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h4 id="4．虚引用（PhantomReference）"><a href="#4．虚引用（PhantomReference）" class="headerlink" title="4．虚引用（PhantomReference）"></a>4．虚引用（PhantomReference）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h4>首先标记出所有不需要回收的对象，再统一回收掉没有被标记的对象。缺点是会产生不连续的内存碎片、且效率不高<h4 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h4>解决效率问题，将内存分为大小相同的两块，每次使用一块。这一块用完后，就将存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<h4 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h4>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<h4 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h4>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>比如在新生代，每次有大量对象死去，可以选择复制算法。老年代中对象存活率高，而且没有额外的空间进行分配担保，所以可以使用标记清除或者标记整理算法<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/vm.png" class title="vm"><h4 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h4>单线程收集器，在进行垃圾收集工作时必须暂停其他所有的工作线程，直到收集结束。优点是简单高效。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</li></ul><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h4 id="2、ParNew-收集器"><a href="#2、ParNew-收集器" class="headerlink" title="2、ParNew 收集器"></a>2、ParNew 收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。同样需要暂停其它工作进程。它是许多运行在 Server 模式下的虚拟机的首要选择。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h4 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel Scavenge 收集器"></a>3、Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</strong></p><h4 id="4、Serial-Old-收集器"><a href="#4、Serial-Old-收集器" class="headerlink" title="4、Serial Old 收集器"></a>4、Serial Old 收集器</h4><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h4 id="5、Parallel-Old-收集器"><a href="#5、Parallel-Old-收集器" class="headerlink" title="5、Parallel Old 收集器"></a>5、Parallel Old 收集器</h4><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h4 id="6、CMS-收集器"><a href="#6、CMS-收集器" class="headerlink" title="6、CMS 收集器"></a>6、CMS 收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong><br><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong><br>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。 </li></ul><img src="/Craaaazy/Craaaazy.github.io/2021/04/09/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" class title="CMS收集器"><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong><h4 id="7、G1-收集器"><a href="#7、G1-收集器" class="headerlink" title="7、G1 收集器"></a>7、G1 收集器</h4></li></ul><p>**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC **<strong>停顿时间要求的同时,还具备高吞吐量性能特征。</strong>从整体来看是基于标记-整理算法，从局部来看是基于复制算法实现。<br>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。<br>jdk9默认gc。</p><h3 id="常用-GC-调优策略"><a href="#常用-GC-调优策略" class="headerlink" title="常用 GC 调优策略"></a>常用 GC 调优策略</h3><h4 id="1-GC-调优原则"><a href="#1-GC-调优原则" class="headerlink" title="1. GC 调优原则"></a>1. GC 调优原则</h4><p>在调优之前，我们需要记住下面的原则：</p><blockquote><p>多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。</p></blockquote><h4 id="2-GC-调优目的"><a href="#2-GC-调优目的" class="headerlink" title="2. GC 调优目的"></a>2. GC 调优目的</h4><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h4 id="3-GC-调优策略"><a href="#3-GC-调优策略" class="headerlink" title="3. GC 调优策略"></a>3. GC 调优策略</h4><p><strong>策略 1：</strong>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。<br><strong>策略 2：</strong>大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。<code>-XX:PretenureSizeThreshold</code> 可以设置直接进入老年代的对象大小。<br><strong>策略 3：</strong>合理设置进入老年代对象的年龄，<code>-XX:MaxTenuringThreshold</code> 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。<br><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：<code>-Xms</code> 初始化堆大小，<code>-Xmx</code> 最大堆大小。<br><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote><h2 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h2><h3 id="类加载器的流程"><a href="#类加载器的流程" class="headerlink" title="类加载器的流程"></a>类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li><p>将class文件加载到内存</p></li><li><p>将静态数据结构转化成方法区中运行时的数据结构</p></li><li><p>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4></li><li><p>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</p></li><li><p>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p></li><li><p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3. 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><h3 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p></li><li><p>BootStrap ClassLoader：rt.jar</p></li><li><p>Extension ClassLoader: 加载扩展的jar包</p></li><li><p>App ClassLoader：指定的classpath下面的jar包</p></li><li><p>Custom ClassLoader：自定义的类加载器</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
