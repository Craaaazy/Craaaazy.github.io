

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="MySQL和sqlserver的区别MySQL体积小、速度快、总体拥有成本低，开源；MySQL的核心程序采用完全的多线程编程。线程是轻量级的进程，它可以灵活地为用户提供服务，而不过多的系统资源。用多线程和C语言实现的mysql能很容易充分利用CPU；有很多存储引擎可以选择，如MyISAM, Heap, InnoDB, and Berkeley DB。但是缺乏一些存储过程功能。但是在多表关联、子查询">
  <meta name="author" content="Acur Ning">
  <meta name="keywords" content="">
  
  <title>数据库相关 - 笔记本</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"craaaazy.github.io","root":"/","version":"1.8.9-a","typing":{"enable":false,"typeSpeed":60,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>笔记</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-book"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据库相关">
              
                数据库相关
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-10 13:44" pubdate>
        2021年4月10日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      76
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据库相关</h1>
            
            <div class="markdown-body">
              <h1 id="MySQL和sqlserver的区别"><a href="#MySQL和sqlserver的区别" class="headerlink" title="MySQL和sqlserver的区别"></a>MySQL和sqlserver的区别</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>体积小、速度快、总体拥有成本低，开源；MySQL的核心程序采用完全的多线程编程。线程是轻量级的进程，它可以灵活地为用户提供服务，而不过多的系统资源。用多线程和C语言实现的mysql能很容易充分利用CPU；<br>有很多存储引擎可以选择，如MyISAM, Heap, InnoDB, and Berkeley DB。但是缺乏一些存储过程功能。<br>但是在多表关联、子查询优化、统计函数等方面是软肋，而且只支持极简单的HINT。</p>
<h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><p>稳定性强，代价是增加额外的复杂操作，磁盘存储，内存损耗等等，需要更强的硬件支持。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>MySQL简单查询非常快，但是用函数/join/group等方式查时会慢一些。sqlserver的简单查询速度不如MySQL，但在复杂查询时，性能降低得不多。但MySQL可以通过针对表结构设计来避免复杂查询（多冗余，少关联）。sqlserver的并发性能不如MySQL。<br>sqlserver的性能比MySQL要好。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>sqlserver功能比mysql多，比如存储过程/触发器/丰富的函数/图形化管理页面/自动维护的计划任务等</p>
<h2 id="安全功能"><a href="#安全功能" class="headerlink" title="安全功能"></a>安全功能</h2><p>MySQL有一个用于改变数据的二进制日志。因为它是二进制，这一日志能够快速地从主机上复制数据到客户机上。即使服务器崩溃，这一二进制日志也会保持完整，而且复制的部分也不会受到损坏。 <br>在SQL服务器中，你也可以记录SQL的有关查询，但这需要付出很高的代价。 </p>
<h1 id="常见sql优化策略"><a href="#常见sql优化策略" class="headerlink" title="常见sql优化策略"></a>常见sql优化策略</h1><p>首先，对于MySQL层优化我一般遵从五个原则：</p>
<ol>
<li>减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</li>
<li>返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io</li>
<li>减少交互次数：批量DML操作，函数存储等减少数据连接次数</li>
<li>减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</li>
<li>利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源<span id="more"></span>
总结到SQL优化中，就三点:</li>
</ol>
<ul>
<li>最大化利用索引；</li>
<li>尽可能避免全表扫描；</li>
<li>减少无效数据的查询；</li>
</ul>
<p>理解SQL优化原理 ，首先要搞清楚SQL执行顺序：</p>
<h2 id="SELECT语句-语法顺序："><a href="#SELECT语句-语法顺序：" class="headerlink" title="SELECT语句 - 语法顺序："></a><strong>SELECT语句 - 语法顺序：</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT <span class="hljs-operator">&lt;</span>limit_number<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="SELECT语句-执行顺序："><a href="#SELECT语句-执行顺序：" class="headerlink" title="SELECT语句 - 执行顺序："></a><strong>SELECT语句 - 执行顺序：</strong></h2><p><strong>FROM</strong><br>&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。<br><strong>ON</strong><br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br>**JOIN **&lt;join, left join, right join…&gt;<br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br><strong>WHERE</strong><br>&lt;where条件&gt; # 对上述虚表进行筛选<br><strong>GROUP BY</strong><br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br><strong>HAVING</strong><br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br><strong>SELECT</strong><br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br><strong>DISTINCT</strong></p>
<h1 id="数据除重"><a href="#数据除重" class="headerlink" title="数据除重"></a>数据除重</h1><p><strong>ORDER BY</strong><br>&lt;排序条件&gt; # 排序<br><strong>LIMIT</strong><br>&lt;行数限制&gt;</p>
<h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a><strong>SQL优化策略</strong></h2><p><strong>来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/299051996">SQL优化最干货总结（2020最新版）</a></strong></p>
<h3 id="一、避免不走索引的场景"><a href="#一、避免不走索引的场景" class="headerlink" title="一、避免不走索引的场景"></a>一、避免不走索引的场景</h3><p><strong>1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%陈%&#x27;</span><br></code></pre></td></tr></table></figure>
<p>优化方式：尽量在字段后面使用模糊查询。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;陈%&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果需求是要在前面使用模糊查询，</p>
<ul>
<li>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置</li>
<li>使用FullText全文索引，用match against 检索</li>
<li>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级</li>
<li>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。</li>
</ul>
<p><strong>2. 尽量避免使用in 和not in，会导致引擎走全表扫描。</strong>如下（此处已经被优化，mysql优化器会判断全表扫描快or索引快）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<p>优化方式：如果是连续数值，可以用between代替。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>如果是子查询，可以用exists代替。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走索引</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B);<br><span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id);<br></code></pre></td></tr></table></figure>
<p><strong>3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：（并非所有的or都用不到索引）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>优化方式：可以用union代替or。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>4. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> score <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure>
<p>优化方式：可以给字段添加默认值0，对0值进行判断。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。</strong><br>可以将表达式、函数操作移动到等号右侧。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 全表扫描</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score<span class="hljs-operator">/</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br><span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-operator">*</span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p><strong>6. 当数据量大时，避免使用where 1=1的条件。</strong>通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> username, age, sex <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。<br><strong>7. 查询条件不能用 &lt;&gt; 或者 !=</strong><br>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。<br><strong>8. where条件仅包含复合索引非前置列</strong><br>如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part2<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> key_part3<span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>9. 隐式类型转换造成不使用索引</strong><br>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> col_varchar<span class="hljs-operator">=</span><span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure>
<p><strong>10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br> <br><span class="hljs-comment">-- 走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure>
<p>对于上面的语句，数据库的处理顺序是：</p>
<ul>
<li>第一步：根据where条件和统计信息生成执行计划，得到数据。</li>
<li>第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。</li>
<li>第三步：返回排序后的数据。</li>
</ul>
<p>当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。<br>这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。<br><strong>11. 正确使用hint优化语句</strong><br>MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。</p>
<ol>
<li>USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)…</li>
<li>IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) …</li>
<li>FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) …</li>
</ol>
<p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。<br>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="hljs-keyword">WHERE</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure>
<h3 id="二、SELECT语句其他优化"><a href="#二、SELECT语句其他优化" class="headerlink" title="二、SELECT语句其他优化"></a>二、SELECT语句其他优化</h3><p>**1. 避免出现select ***<br>首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。<br>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。<br>建议提出业务实际需要的列数，将指定列名以取代select *。<br><strong>2. 避免出现不确定结果的函数</strong><br>特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。<br><strong>3.多表关联查询时，小表在前，大表在后。</strong><br>在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。<br>例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。<br><strong>4. 使用表的别名</strong><br>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。<br><strong>5. 用where字句替换HAVING字句</strong><br>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。<br>where和having的区别：where后面不能使用组函数<br><strong>6.调整Where字句中的连接顺序</strong><br>MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</p>
<h2 id="left-join-和inner-join"><a href="#left-join-和inner-join" class="headerlink" title="left join 和inner join"></a>left join 和inner join</h2><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 <br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42181824/article/details/82261988">数据库索引原理，及MySQL索引类型</a></p>
<h2 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h2><p>一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。</p>
<h3 id="索引的不足之处"><a href="#索引的不足之处" class="headerlink" title="索引的不足之处"></a>索引的不足之处</h3><p>过多的使用索引将会造成滥用。因此索引也会有它的缺点：</p>
<ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</li>
</ul>
<p>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<h3 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h3><ol>
<li>表记录太少</li>
<li>经常插入、删除、修改的表</li>
<li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li>
<li>经常和主字段一块查询但主字段索引值比较多的表字段<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3>使用索引时，有以下一些技巧和注意事项：</li>
</ol>
<ul>
<li>索引不会包含有NULL值的列</li>
</ul>
<p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
<ul>
<li>使用短索引</li>
</ul>
<p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
<ul>
<li>索引列排序</li>
</ul>
<p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
<ul>
<li>like语句操作</li>
</ul>
<p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>
<ul>
<li><p>不要在列上进行运算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-keyword">YEAR</span>(adddate)<span class="hljs-operator">&lt;</span><span class="hljs-number">2007</span>;<br></code></pre></td></tr></table></figure>
<p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> adddate<span class="hljs-operator">&lt;</span>‘<span class="hljs-number">2007</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>’;<br></code></pre></td></tr></table></figure></li>
<li><p>不使用NOT IN和&lt;&gt;操作</p>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3></li>
</ul>
<ol>
<li>存在null值</li>
<li>not条件（不要用not in 或者 not exist）</li>
<li>like ‘%xx’（通配符在前时）</li>
<li>条件包括函数</li>
<li>数据类型转换</li>
<li>范围条件(&lt;，&gt;)后列出索引<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4>最基本类型，没有任何限制，唯一的任务就是加快访问速度。允许在定义的列中添加重复值和空值。<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4>唯一索引和普通索引类似，避免数据出现重复。<br>值必须唯一可以为空。一般用create unique index创建。<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4>特殊的唯一索引，不能用create index创建，唯一且不空。表中只有一个主键索引。<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4>对文本内容进行搜索的索引。<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4>多列值组成的一个索引，专门用于组合索引，效率大于索引合并。<h3 id="从物理角度"><a href="#从物理角度" class="headerlink" title="从物理角度"></a>从物理角度</h3><h4 id="聚集索引（聚簇索引（Clustered-Index））"><a href="#聚集索引（聚簇索引（Clustered-Index））" class="headerlink" title="聚集索引（聚簇索引（Clustered Index））"></a>聚集索引（聚簇索引（Clustered Index））</h4>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。<br>聚集索引确定表中数据的物理顺序。聚集索引类似于字典，按字母排序，每个字母下有多个字（相当于数据列）。所以对于聚集索引，叶子结点即存储了真实的数据行。所以通过聚集索引可以直接获取到数据库中的数据。<br>一般建表的时候，数据库就会为主键建立了聚簇索引<h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。<br>非聚集索引的叶层不包含数据页， 叶结点包含索引字段值及指向数据页数据行的逻辑指针（每个索引行包含非聚集键值以及一个或多个行定位器，这些行定位器指向有该键值的数据行（如果索引不唯一，则可能是多行））。所以非聚集索引不能直接获取到数据，需要通过定位器来获取数据。</li>
</ol>
<h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul>
<li>InnoDB：事物优先（适合高并发，是行锁）</li>
<li>MyISAM：性能优先（表锁）<h3 id="表锁与行锁"><a href="#表锁与行锁" class="headerlink" title="表锁与行锁"></a>表锁与行锁</h3>当插入数据时，就锁定表，这叫做”锁表”；当更新数据时，就锁定行，这叫做”锁行”。<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li>
</ul>
<ol>
<li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p>
</li>
<li><p>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
</li>
<li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
</li>
<li><p>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3></li>
<li><p>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>
</li>
<li><p>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p>
</li>
<li><p>系统奔溃后，MyISAM恢复起来更困难，能否接受；</p>
</li>
<li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p>
<h1 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h1><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
</li>
</ol>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong><br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h2 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些?"></a>事务隔离级别有哪些?</h2><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p>
<h1 id="mysql-explain解释"><a href="#mysql-explain解释" class="headerlink" title="mysql explain解释"></a>mysql explain解释</h1><h2 id="EXPLAIN列的解释："><a href="#EXPLAIN列的解释：" class="headerlink" title="EXPLAIN列的解释："></a>EXPLAIN列的解释：</h2></li>
<li><p>table：显示这一行的数据是关于哪张表的</p>
</li>
<li><p>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL</p>
</li>
<li><p>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>
</li>
<li><p>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p>
</li>
<li><p>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
</li>
<li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
</li>
<li><p>rows：MYSQL认为必须检查的用来返回请求数据的行数</p>
</li>
<li><p>Extra：关于MYSQL如何解析查询的额外信息。坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢</p>
<h2 id="Extra列返回的描述的意义"><a href="#Extra列返回的描述的意义" class="headerlink" title="Extra列返回的描述的意义:"></a>Extra列返回的描述的意义:</h2></li>
<li><p>Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p>
</li>
<li><p>Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了</p>
</li>
<li><p>Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p>
</li>
<li><p>Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行</p>
</li>
<li><p>Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候</p>
</li>
<li><p>Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p>
</li>
<li><p>Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</p>
</li>
<li><p>system 表只有一行：system表。这是const连接类型的特殊情况</p>
</li>
<li><p>const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待</p>
</li>
<li><p>eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用</p>
</li>
<li><p>ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好</p>
</li>
<li><p>range:这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况</p>
</li>
<li><p>index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）</p>
</li>
<li><p>ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免.</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/database/">database</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/10/Java%20Concurrency/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java并发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/09/JVM/">
                        <span class="hidden-mobile">JVM</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
